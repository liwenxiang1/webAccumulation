## 原型与原型链

在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 `prototype` 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个`指针`，这个指针指向构造函数的 `prototype` 属性对应的值，在 ES5 中这个`指针`被称为`对象的原型`。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 `__proto__` 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 `Object.getPrototypeOf()` 方法，可以通过这个方法来获取对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 `Object.prototype` 所以这就是新建的对象为什么能够使用 `toString() `等方法的原因。

> 特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一
> 改变。

**如何获得对象非原型链上的属性？**
使用后`hasOwnProperty()`方法来判断属性是否属于原型链的属性：

```js
function iterate(obj) {
  var res = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) res.push(key + ': ' + obj[key]);
  }
  return res;
}
```

**执行上下文中 `this` 的指向：**

1. 在全局执行上下文中，`this` 指向全局对象（window 对象）
2. 在函数执行上下文中，`this` 指向取决于函数如何调用。如果它被一个引用对象调用，那么 **`this` 会被设置成那个对象**，否则**this 的值被设置为全局对象或者 undefined**
