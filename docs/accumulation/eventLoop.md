<!--
 * @Author: liwenxiang
 * @Date: 2024-03-04 20:58:21
 * @LastEditors: liwenxiang
 * @LastEditTime: 2024-03-04 21:45:41
-->

# 事件循环（Event Loop）以及实例

大家都知道 js 是单线程的脚本语言，在同一时间只能做同一件事，为了协调时间，用户交互，脚本，UI 渲染和网络处理等行为，为了防止线程阻塞，Event Loop 应运而生

**为什么 js 是单线程的**
js 是运行在浏览器的脚本语言，js 的主要用途之一是操作 dom

举个例子，如果 js 有两个线程，同时操作同一个 dom，浏览器该怎么办呢？为了避免这种情况，js 必须是单线程的

## 执行栈与任务队列

因为 js 是单线程云烟，到遇到一步任务时，不可能一直等待一步完成，再进行下一步，这期间浏览器是空闲状态，这是对资源的浪费

### 执行栈（调用栈）

当执行某个函数、用户点击一次数遍，ajax 完成，一个图片加载完成等时间发生时，只要指定过回调函数，这些时间发生时就会进入执行栈队列中，等待主线程读取，遵循先进后出原则

### 主线程

主线程规定现在执行`执行栈`中的那个任务

主线程循环：即主线程会不停地从执行栈中读取事件，执行栈中的同步代码

当遇到一个异步事件后，也不会一直等待一不执行的返回结果，而是会挂载到执行队列中（Task Queue）

**当主线程执行完执行栈中所有的代码之后，回去查看任务队列中是否有任务**。如果有，主线正会一次执行任务队列中的回调函数

**代码示例**

```js
let a = () => {
	setTimeout(() => {
		console.log('任务队列函数1')
	}, 0)
	for (let i = 0; i < 5000; i++) {
		console.log('a的for循环')
	}
	console.log('a事件执行完')
}
let b = () => {
	setTimeout(() => {
		console.log('任务队列函数2')
	}, 0)
	for (let i = 0; i < 5000; i++) {
		console.log('b的for循环')
	}
	console.log('b事件执行完')
}
let c = () => {
	setTimeout(() => {
		console.log('任务队列函数3')
	}, 0)
	for (let i = 0; i < 5000; i++) {
		console.log('c的for循环')
	}
	console.log('c事件执行完')
}
a()
b()
c()
// 当a、b、c函数都执行完成之后，三个setTimeout才会依次执行
```

### js 异步运行机制

1. 所有任务都在主线程上执行，行程一个执行栈
2. 主线程之外还有一个“任务队列”只要一步任务有了结果，就会在“任务队列”中防止一个时间
3. 一旦“执行栈”中所有的任务执行完毕，系统就会读取“任务队列”。那些对应的异步任务，结束等待状态，进入执行栈并开始执行

### 宏任务与微任务

异步任务分为宏任务和微任务

**宏任务**

script(整体代码)，setTimeout,setInterval,Ui 渲染，I/O，postMessage,MessageChannel,setImmediate

**微任务**

Promise、mutationObserve、process.nextTick

### Event Loop（事件循环）

Event Loop 中每一次循环成为 tick,每一次 tick 的任务如下

- 执行栈选择最先进入队列的宏任务（通常是`script`整体代码），如果有则执行
- 检查是否存在微任务，如果存在则不停执行，直至清空微任务队列
- 更新 render（每一次时间循环，浏览器都会去更新重新渲染）
- 重复以上步骤

宏任务 > 所有微任务 > 宏任务
