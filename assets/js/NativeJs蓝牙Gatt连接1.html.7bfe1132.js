"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[6628],{5218:(e,i,n)=>{n.r(i),n.d(i,{comp:()=>c,data:()=>r});var s=n(641);const l=(0,s.Fv)('<h1 id="nativejs使用gatt方式连接蓝牙" tabindex="-1"><a class="header-anchor" href="#nativejs使用gatt方式连接蓝牙"><span>NativeJs使用Gatt方式连接蓝牙</span></a></h1><h3 id="一、蓝牙功能说明" tabindex="-1"><a class="header-anchor" href="#一、蓝牙功能说明"><span>一、蓝牙功能说明</span></a></h3><p>蓝牙功能简单说来就是：1.蓝牙设备的连接。2.蓝牙设备的数据交换（这部分没有太多深入研究，直接使用之前的代码）。</p><blockquote><p>目前项目中接触到的蓝牙连接分为三种类型：</p><ul><li>1.<code>Gatt方式连接</code>——代码中使用<code>gatt</code>方式直接连接</li><li>2.<code>createBond-pin码方式连接</code>——现实场景中是连接蓝牙设备时，输入蓝牙设备的<code>pin码</code>进行连接。这个功能可以使用代码实现</li><li>3.<code>createBond-setPairingConfirmation方式连接</code>——现实场景中是连接蓝牙设备时，弹窗确认蓝牙匹配进行连接。这个功能需要是系统应用才可以实现。</li></ul></blockquote><p>前面两种都是已知蓝牙设备的特定信息可以直接连接上。</p><p>后面这种【确认配对】的方式因为没有蓝牙的信息需要有Android系统权限【android.permission.BLUETOOTH_PRIVILEGED】但是这个权限是需要【系统应用】才可以拥有的，所以这种方式连接不上。</p><h3 id="二、蓝牙gatt方式连接过程" tabindex="-1"><a class="header-anchor" href="#二、蓝牙gatt方式连接过程"><span>二、蓝牙Gatt方式连接过程</span></a></h3><p>在连接前就知道了目标蓝牙设备的MAC地址</p><ul><li>1.应用具有【定位权限】(并且需要Android设备打开系统定位功能)</li><li>2.判断Android蓝牙功能是否打开，没有打开则打开蓝牙</li><li>3.使用Android蓝牙扫描功能发现附近蓝牙设备</li><li>4.判断扫描到的蓝牙设备的MAC地址和目标蓝牙设备的MAC地址匹配，使用Gatt方式连接目标蓝牙设备</li><li>5.Android分段分批使用Gatt方式发送数据到蓝牙设备，每次发送后蓝牙设备也会通过Gatt方式返回数据，Android将返回的数据过滤拼接使用。</li><li>6.重复步骤<code>5</code>的操作3次左右，整个数据传输完成。</li></ul><h3 id="三、项目中的蓝牙连接代码分析" tabindex="-1"><a class="header-anchor" href="#三、项目中的蓝牙连接代码分析"><span>三、项目中的蓝牙连接代码分析：</span></a></h3><p>核心功能分析：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b020696e68ce41ac9ac3b6f967176017~tplv-k3u1fbpfcp-watermark.image?" alt="Gatt蓝牙数据传输.png"></p><blockquote><p><code>BlueUtils</code>(blue-utils.js)：主要作用是Android蓝牙打开、蓝牙设备连接、蓝牙数据传输</p></blockquote><blockquote><p><code>Request</code>(request.js)：主要作用是请求后台接口获取<code>bwnr</code>报文内容字符串及发送<code>bwnr</code></p></blockquote><blockquote><p><code>BluePlus</code>(blue-plus.js)：主要作用是提供方法供页面使用及数据回调到页面。提供的方法包括： 使用<code>BlueUtils</code>和<code>Request</code>进行蓝牙连接，蓝牙数据传输等。将<code>bwnr</code>分段处理及回来的数据处理。</p></blockquote><h4 id="_1-blueutils代码分析" tabindex="-1"><a class="header-anchor" href="#_1-blueutils代码分析"><span>1.<code>BlueUtils</code>代码分析：</span></a></h4><p><em>0.对外提供的方法有：</em></p><ul><li>0.<code>constructor(deviceId)</code><ul><li>蓝牙设备的<code>MAC地址</code>需要通过参数传入（本项目中这里是写死的）</li></ul></li><li>1.<code>startBluetoothDevicesDiscovery({readyBack,valueBack})</code><ul><li><code>readyBack</code>是连接到目标蓝牙后的回调</li><li><code>valueBack</code>是接收到蓝牙设备返回的数据回调</li></ul></li><li>2.<code>writeValue(value)</code><ul><li>向目标蓝牙设备写入数据，需要在上面的<code>readyBack</code>之后使用。</li></ul></li></ul><p><em>1.部分代码介绍：</em></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>class BlueUtils {\n    constructor() {...}\n\n    canBlueToothUse(){//蓝牙硬件是否可用\n        1.判断当前设备是否支持蓝牙，支持蓝牙则走下面的逻辑！\n        this.blueToothError = await this.openLocationPermission()\n        这里就可以使用await接收到【申请权限方法】的同步结果。\n        2.判断定位权限是否存在，不存在则去请求权限，存在则走下面的逻辑！\n        3.判断蓝牙功能是否打开，没打开则去申请打开，打开则走下面的逻辑！\n        4.上面的功能在不满足的情况下就提示错误信息，并返回false结果。\n    }\n\n    //这个方法的作用就是统一日志输出。正常情况下只需要传入fn方法名及e有用信息两个参数即可\n    //如果在【Promise】对象中使用时，先输出console日志，然后再通过【resolve】方法将【e有用信息】回调到【Promise】对象中。\n    promiseBackSuccess(fn, e, back = null) {\n      console.log(fn + &quot;---success&quot;, e)\n      if (back) back(e)\n    }\n\n    //上面的方法在这里有使用，目的就是在【Promise】中先输出日志，然后再将结果返回去。\n    openLocationPermission() {//申请定位权限\n      return new Promise((resolve, reject) =&gt; {\n        plus.android.requestPermissions([&#39;android.permission.ACCESS_FINE_LOCATION&#39;],\n            e =&gt; {\n              if (e.deniedAlways.length &gt; 0) this.promiseBackFail(&quot;requestPermissions_ACCESS_FINE_LOCATION&quot;, &quot;定位权限被拒绝！&quot;, reject)\n              if (e.deniedPresent.length &gt; 0) this.promiseBackFail(&quot;requestPermissions_ACCESS_FINE_LOCATION&quot;, &quot;定位权限被拒绝！&quot;, reject)\n              if (e.granted.length &gt; 0) this.promiseBackSuccess(&quot;requestPermissions_ACCESS_FINE_LOCATION&quot;, &quot;&quot;, resolve)\n            },\n            err =&gt; {\n              this.showToast(&quot;申请权限出错！&quot;)\n              this.promiseBackFail(&quot;requestPermissions_ACCESS_FINE_LOCATION&quot;, JSON.stringify(err), reject)\n            });\n      })\n    }\n    \n    //开启蓝牙扫描-连接方法\n    startBluetoothDevicesDiscovery(){\n        //1.判断蓝牙功能是否可用，不可用去申请相关权限或提示错误信息\n        let blueToothUse = await this.canBlueToothUse()\n        if (!blueToothUse) return\n        //2.以下都是调用【plus的蓝牙扫描、扫描监听、连接方法】的完整流程\n        this.listenBlueToothAdapter()【扫描监听放在扫描的前面】\n        let openRes = await this.openBlueTooth()\n        let startDisRes = await this.startDiscovery()\n    }\n    \n    listenBlueToothAdapter(){\n        plus.bluetooth.onBluetoothDeviceFound(e =&gt; {\n            if (deviceObj.deviceId == this.deviceId) {\n                this.connectDevice(success=&gt; //扫描到目标蓝牙，进行连接操作\n                    this.getServices(success=&gt; //sccess：连接成功，获取蓝牙服务\n                        if (services.length &gt; 0) {//success:获取服务成功，并且服务存在：\n                          this.listenValueChange(success=&gt;\n                            //到这里才是真正意义上的连接上蓝牙  \n                            this.readValueListener()//监听蓝牙返回的数据\n                          )\n                          this.clearServiceTimer()\n                        }\n                    )\n                )\n            }\n        })\n    }\n    \n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>canBlueToothUse</code>方法中的几个判断，都是使用<code>await</code>得到<code>Promoise</code>的同步结果，这样看起来更清晰。各个独立的方法只处理自己的业务逻辑即可，防止了多层嵌套的代码逻辑。</p><ul><li>1.打开定位权限可以直接使用plus提供的方法<code>plus.android.requestPermissions</code></li><li>2.打开蓝牙需要调用Android原生的api代码： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fa863fe102b4f71b5e63b5632fb6639~tplv-k3u1fbpfcp-watermark.image?" alt="ic_blueutils_code.png"></li></ul><p><em>2.核心代码介绍：</em></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>class BlueUtils {\n    \n    //这里实际上是真正的Gatt连接\n    listenValueChange() {\n        plus.bluetooth.notifyBLECharacteristicValueChange({\n          deviceId: this.deviceId,\n          serviceId: &#39;6E400001-B5A3-F393-E0A9-E50E24DCCA9E&#39;,\n          characteristicId: &#39;6E400003-B5A3-F393-E0A9-E50E24DCCA9E&#39;,\n          success: e =&gt; {},\n          fail: e =&gt; {}\n        })\n    }\n    \n    //Gatt方式监听蓝牙返回的数据\n    readValueListener() {\n      plus.bluetooth.onBLECharacteristicValueChange(e =&gt; {\n        console.error(&quot;2&gt;&gt;&gt;onBLECharacteristicValueChange &gt;&gt;&gt;&gt;&gt;&quot;, JSON.stringify(e))\n        // console.error(&quot;2.1&gt;&gt;&gt;onBLECharacteristicValueChange &gt;&gt;&gt;&gt;&gt;&quot;, e.value)\n        if (this.blueToothBack) this.blueToothBack(e)\n      })\n    }\n    \n    //Gatt方式向蓝牙设备写入数据\n    writeValue(value) {\n      return new Promise((resolve, reject) =&gt; {\n        plus.bluetooth.writeBLECharacteristicValue({\n          deviceId: this.deviceId,\n          serviceId: &quot;6E400001-B5A3-F393-E0A9-E50E24DCCA9E&quot;,\n          characteristicId: &quot;6E400002-B5A3-F393-E0A9-E50E24DCCA9E&quot;,\n          value: value,\n          success: e =&gt; this.promiseBackWarning(&quot;1&gt;&gt;&gt;writeBLECharacteristicValue&quot;, &quot;success&quot;, e, resolve),\n          fail: e =&gt; this.promiseBackWarning(&quot;writeBLECharacteristicValue&quot;, &quot;fail&quot;, e, reject)\n        })\n      })\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>plus.bluetooth.notifyBLECharacteristicValueChange</code>和<code>plus.bluetooth.writeBLECharacteristicValue</code>方法都需要以下参数：</p><ul><li>1.【deviceId】</li><li>2.【serviceId】</li><li>3.【characteristicId】这个值是不同的</li></ul>',26),d={href:"https://gitee.com/zyjun/bluetooth",target:"_blank",rel:"noopener noreferrer"},t=(0,s.Fv)('<h4 id="_2-blueplus代码分析" tabindex="-1"><a class="header-anchor" href="#_2-blueplus代码分析"><span>2.<code>BluePlus</code>代码分析：</span></a></h4><p><em>1.代码分析：</em></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>class BlueUtils {\n    constructor(state) {\n      this.blueUtils = new BlueUtils()\n      this.dataUtils = new DataUtils()\n      this.request = new Request()\n    }\n\n    async startBluetoothDiscovery() {\n      await this.blueUtils.startBluetoothDevicesDiscovery({\n        readyBack: async () =&gt; {//蓝牙准备就绪，请求接口，发送第一条bwnr\n          console.log(&quot;startBluetoothDevicesDiscovery---readyBack&quot;)\n          let bwnr = await this.request.firstRequest()\n          console.log(&quot;&lt;&lt;&lt;&lt;&lt;第1次请求报文内容&quot;, bwnr)\n          if (bwnr) this.firstSendData(bwnr)\n        },\n        valueBack: async (e) =&gt; {\n          console.error(&quot;3&gt;&gt;&gt;startBluetoothDevicesDiscovery---valueBack&quot;, this.dataUtils.buffer2hex(e.value))\n          if (e.value != undefined) this.receiveBlueValue(e)\n        }\n      })\n    }\n    \n    queryData = res =&gt; {\n      //todo 处理页面逻辑\n      if (res.ywbsm === &#39;000104&#39;) {\n        console.log(&#39;queryData---000104&#39;)\n        this.firstSendData(res.bwnr)\n      } else if (res.ywbsm === &#39;500601&#39;) {\n        console.log(&#39;queryData---500601&#39;)\n        this.showToast(&quot;流程结束！&quot;)\n      } else {\n        console.log(&quot;?????????????queryData------------writeValue?????????????&quot;)\n        this.blueUtils.writeValue(res.bwnr)\n      }\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在调用<code>blueUtils.startBluetoothDevicesDiscovery</code>之后，</p><ul><li>1.监听<code>readyBack</code>蓝牙连接成功后，请求后台接口获取<code>bwnr</code>字符串</li><li>2.执行<code>firstSendData</code>方法将<code>bwnr</code>分割后保存到<code>sendMsgArr</code>数组中分批次发送数据到蓝牙设备 <ul><li>2.1每次发送数据到蓝牙设备后，会通过<code>valueBack</code>监听到蓝牙设备回传回来的数据，将回传的数据保存</li></ul></li><li>3.判断<code>endFlag == &#39;end&#39;</code>表示分批次传输<code>bwnr</code>报文内容数据完成。</li><li>4.进入下一次的<code>secondSendData</code>逻辑。 <ul><li>4.1将<code>2.1</code>接收到的<code>receivedData</code>拼接当作参数传给接口再次获取<code>bwnr</code>数据</li><li>4.2获取到接口数据后，执行<code>queryData</code>方法 <ul><li>4.2.1判断<code>res.ywbsm === &#39;000104&#39;</code>继续执行<code>firstSendData</code>方法，进入到上面的<code>2-3-4</code>逻辑</li><li>4.2.2判断<code>res.ywbsm === &#39;500601&#39;</code>整个数据交换逻辑完成，得到<code>bwnrJq = res.bwnr</code>充值结果。</li></ul></li></ul></li></ul><p>这里的数据处理及交互逻辑都是复用之前的逻辑，所以代码感觉有点乱。 大概看一下即可，每个项目可能这部分的代码不太一样。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code></code></pre><div class="line-numbers" aria-hidden="true"></div></div>',7),a={},c=(0,n(6262).A)(a,[["render",function(e,i){const n=(0,s.g2)("ExternalLinkIcon");return(0,s.uX)(),(0,s.CE)("div",null,[l,(0,s.Lk)("blockquote",null,[(0,s.Lk)("p",null,[(0,s.eW)("这些特征值需要硬件方提供，或者使用"),(0,s.Lk)("a",d,[(0,s.eW)("bluetooth-android"),(0,s.bF)(n)]),(0,s.eW)("这个Android项目获取到。")])]),t])}]]),r=JSON.parse('{"path":"/markdown/%E5%89%8D%E7%AB%AF/%E8%B0%83%E7%A0%94%E6%B5%8B%E8%AF%95/NativeJs%E8%93%9D%E7%89%99Gatt%E8%BF%9E%E6%8E%A51.html","title":"NativeJs使用Gatt方式连接蓝牙","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"一、蓝牙功能说明","slug":"一、蓝牙功能说明","link":"#一、蓝牙功能说明","children":[]},{"level":3,"title":"二、蓝牙Gatt方式连接过程","slug":"二、蓝牙gatt方式连接过程","link":"#二、蓝牙gatt方式连接过程","children":[]},{"level":3,"title":"三、项目中的蓝牙连接代码分析：","slug":"三、项目中的蓝牙连接代码分析","link":"#三、项目中的蓝牙连接代码分析","children":[]}],"git":{},"filePathRelative":"markdown/前端/调研测试/NativeJs蓝牙Gatt连接1.md"}')}}]);