"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[8339],{6864:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>i,data:()=>l});var e=a(641);const t=a.p+"assets/img/catch返回值.d8a05951.jpg",p=a.p+"assets/img/Promise的allSettled.bfa821de.jpg",o=[(0,e.Fv)('<h1 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span>Promise</span></a></h1><p>是一种规范，承诺</p><blockquote><p>产生背景：解决 1、 回调地狱 2、 沟通成本高</p></blockquote><p>原先：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// successCallback成功, errorCallback失败。只是一种解决方案，并不是一种规范</span>\n<span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> successCallback<span class="token punctuation">,</span> errorCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>ES6-Promise:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 传入的函数被称为executor并立即执行,resolve成功回调，reject失败回调</span>\n<span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 异步操作</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 调用resolve函数，表示promise对象已经成功完成。进入then第一个回调</span>\n    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 调用reject函数，表示promise对象运行失败。进入then第二个回调</span>\n    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n<span class="token comment">// 成功</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n<span class="token comment">// 失败</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="promise-的状态" tabindex="-1"><a class="header-anchor" href="#promise-的状态"><span>Promise 的状态</span></a></h2><p>执行 executor 函数时，Promise 实例处于 pending 状态，一旦调用 resolve 或 reject，Promise 实例的状态就变为 fulfilled 或 rejected，这时称为 resolved（已定型）。</p><ol><li>pending: 初始状态，不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ol><p><strong>注意：</strong></p><ol><li>如果 resolve 的参数是 Promise 对象，那么这个 Promise 对象的状态会传递下去。由新的 Promise 来决定。原来的 Promise 状态不会改变。</li><li>如果 resolve 的参数是一个包含 then 方法的 Object,那么状态是由 then 方法来决定的</li></ol><h2 id="promise-的方法" tabindex="-1"><a class="header-anchor" href="#promise-的方法"><span>Promise 的方法</span></a></h2><ol><li>then: 对象方法,放在了原型上 promise.prototype.then()先 new 一个 promise 对象 promise.then(onFulfilled, onRejected). <ul><li>then 方法可以有返回值，如果返回值是普通类型返回的是一个新的 Promise 对象</li><li>如果返回的是一个新的 Promise 对象，那么这个 Promise 对象的状态由这个新的 Promise 决定</li><li>如果返回的是对象，并且对象实现了 then 方法，返回的是新 promise,状态由 then 函数决定</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>catch: 对象方法。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 方法一</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>\n  <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 方法二，这里的catch是优先捕获promise的，如果promise没有捕获到，才会捕获到then的</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>有返回值，也是返回的 Promise 对象，创建一个新的 promise 对象，调用 resolve 方法 <img src="'+t+'" alt=""></li></ul><ol start="3"><li>finally: 对象方法。ES9 新增的，不管成功还是失败都会被执行一次。</li><li>resolve: 静态方法（类方法），返回一个状态为 fulfilled 的 Promise 对象。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 普通值</span>\n<span class="token keyword">const</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;zyl&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">//传入Promise</span>\n<span class="token keyword">const</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;success&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>reject: 静态方法（类方法），返回一个状态为 rejected 的 Promise 对象。 <strong>无论传入什么。传什么抛出什么，不区分普通值和 Promise</strong></li><li>Promise.all: 接收一个 Promise 实例的数组，返回一个新的 Promise 实例，只有当数组中所有的 Promise 实例都成功时，返回的 Promise 实例才会成功，只要有一个失败，返回的 Promise 实例就会失败。<strong>最终结果按照调用顺序返回，和单独 promise 返回结果顺序无关</strong>。如果其中有一个变成 rejected，那么整个 Promise 就会变成 rejected。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> promise3<span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 所有promise都成功</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 只要有一个失败</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>Promise.allSettled: ES11 新增，接收一个 Promise 实例的数组，返回一个新的 Promise 实例，只有当数组中所有的 Promise 实例都返回结果，<strong>不管是成功还是失败，返回的 Promise 实例才会返回结果</strong>。</li></ol><p>返回结果格式：</p><p><img src="'+p+'" alt=""></p><ol start="8"><li><p>Promise.race: 接收一个 Promise 实例的数组，返回一个新的 Promise 实例，一旦数组中的某个 Promise 实例率先改变状态，返回的 Promise 实例的状态就会改变。</p></li><li><p>Promise.any: ES12 新增，接收一个 Promise 实例的数组，返回一个新的 Promise 实例，只要数组中有一个 Promise 实例成功，返回的 Promise 实例就会成功，只有全部失败，返回的 Promise 实例才会失败。</p></li></ol>',24)],c={},i=(0,a(6262).A)(c,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,o)}]]),l=JSON.parse('{"path":"/markdown/%E5%89%8D%E7%AB%AF/ES6/Promise.html","title":"Promise","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Promise 的状态","slug":"promise-的状态","link":"#promise-的状态","children":[]},{"level":2,"title":"Promise 的方法","slug":"promise-的方法","link":"#promise-的方法","children":[]}],"git":{},"filePathRelative":"markdown/前端/ES6/Promise.md"}')}}]);