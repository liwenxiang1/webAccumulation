"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[3026],{3074:(e,a,p)=>{p.r(a),p.d(a,{comp:()=>n,data:()=>r});var c=p(641);const o=p.p+"assets/img/闭包.5e6d1ea9.png",s=p.p+"assets/img/闭包顺序.1c02f686.jpg",t=[(0,c.Fv)('<h1 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h1><p>词法闭包、函数闭包</p><p><img src="'+o+'" alt=""></p><p><strong>闭包是一个函数+它能访问的自由变量</strong>，每当创建一个函数，就会在函数创建时生成一个闭包。</p><p><strong>执行顺序</strong></p><p>1、代码编译阶段生成一个 GO，存储变量名和变量地址。遇到函数，创建<code>函数对象</code>(函数名、函数体、函数参数、函数返回值、函数作用域链（词法解析的时候就确定了）、函数上下文)</p><p>2、代码执行首先在执行栈里创建一个<code>全局执行上下文</code>，然后执行全局代码，遇到函数，创建<code>函数执行上下文</code>，其中有个 <code>VO+scope chain(VO+parent scope（指着上层作用域的AO）)</code>。然后执行函数，先创建 AO 对象，<code>VO 指向 AO</code>，然后执行函数代码，遇到变量，先在 AO 里找，找不到，再在 VO 里找，找不到，再在全局执行上下文里找，找不到，报错。函数执行完毕后，执行栈中的<code>函数上下文会</code>被销毁</p><p>3、执行 bar 时，依然能访问 foo 中的 name,闭包就形成了。</p><p>bar 以及能访问的自由变量，形成了闭包</p><p><img src="'+s+'" alt=""></p>',10)],d={},n=(0,p(6262).A)(d,[["render",function(e,a){return(0,c.uX)(),(0,c.CE)("div",null,t)}]]),r=JSON.parse('{"path":"/accumulation/%E9%97%AD%E5%8C%85.html","title":"闭包","lang":"zh-CN","frontmatter":{},"headers":[],"git":{},"filePathRelative":"accumulation/闭包.md"}')}}]);