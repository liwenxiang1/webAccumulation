"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[8812],{3560:(e,a,s)=>{s.r(a),s.d(a,{comp:()=>g,data:()=>m});var n=s(641);const t=s.p+"assets/img/事件循环.d20bfd90.jpg",i=s.p+"assets/img/浏览器事件循环.371799d5.jpg",p=s.p+"assets/img/面试题2.937b42d0.jpg",l=s.p+"assets/img/面试题3.a38eacde.jpg",r=s.p+"assets/img/面试题3-1.80260a69.jpg",d=s.p+"assets/img/node阶段.1026069b.jpg",o=s.p+"assets/img/node微任务和宏任务执行顺序.d3cab609.jpg",h=[(0,n.Fv)('<h1 id="浏览器事件循环" tabindex="-1"><a class="header-anchor" href="#浏览器事件循环"><span>浏览器事件循环</span></a></h1><p>js 线程+浏览器其他线程+队列之间的循环组成了浏览器事件循环</p><h2 id="进程和线程" tabindex="-1"><a class="header-anchor" href="#进程和线程"><span>进程和线程</span></a></h2><p>进程：启动一个应用程序，就会默认启动一个进程</p><p>线程：每一个进程中，启动至少一个线程，用于执行程序中的代码，这个线程被称为主线程</p><p><strong>进程是线程的容器</strong></p><p>浏览器是多线程的，js 线程只是其中之一。javascript 是单线程的，但是可以开启多进程。如果比较耗时的操作，不交给 js 线程，交给其他线程，其他线程执行完毕后，再告诉 js 线程，js 线程只负责执行回调函数</p><h2 id="浏览器的事件循环" tabindex="-1"><a class="header-anchor" href="#浏览器的事件循环"><span>浏览器的事件循环</span></a></h2><p><img src="'+t+'" alt=""></p><h2 id="微任务和宏任务" tabindex="-1"><a class="header-anchor" href="#微任务和宏任务"><span>微任务和宏任务</span></a></h2><p><strong>宏任务执行之前，会先执行所有的微任务</strong></p><p>宏任务：ajax、 setTimeout、setInterval、setImmediate、I/O、UI rendering 微任务：Promise.then、process.nextTick、MutationObserver、queueMicrotask</p><p>全局代码（main script）优先执行，然后检查微任务队列，执行微任务，然后检查宏任务队列，执行宏任务，然后检查微任务队列，执行微任务，然后检查宏任务队列，执行宏任务，如此往复</p><p><strong>注意：new Promise 不是微任务，Promise.then 才是微任务。new Promise(()=&gt; {})中的代码是直接执行的</strong></p><p>面试题 1</p><p><img src="'+i+'" alt=""></p><p>面试题 2</p><p><img src="'+p+'" alt=""></p><p>面试题 3</p><p><img src="'+l+'" alt=""></p><p><img src="'+r+'" alt=""></p><h1 id="node-的事件循环" tabindex="-1"><a class="header-anchor" href="#node-的事件循环"><span>Node 的事件循环</span></a></h1><p>libuv 维护了一个 event loop 和 worker threads 池（线程池）</p><h2 id="node-的事件循环分为-6-个阶段" tabindex="-1"><a class="header-anchor" href="#node-的事件循环分为-6-个阶段"><span>node 的事件循环分为 6 个阶段</span></a></h2><p><img src="'+d+'" alt=""></p><p>经常会停留在 I/O 阶段，因为大部分异步任务都在这个阶段执行</p><h2 id="node-的宏任务和微任务" tabindex="-1"><a class="header-anchor" href="#node-的宏任务和微任务"><span>node 的宏任务和微任务</span></a></h2><ul><li>宏任务：Ajax、setTimeout、setInterval、setImmediate、I/O、UI rendering、DOM 事件、关闭回调</li><li>微任务：process.nextTick（优先执行）、Promise.then、MutationObserver、queueMicrotask</li></ul><p><strong>node 微任务和宏任务执行顺序</strong></p><p><img src="'+o+'" alt=""></p><h2 id="node-的事件循环和浏览器的事件循环的区别" tabindex="-1"><a class="header-anchor" href="#node-的事件循环和浏览器的事件循环的区别"><span>node 的事件循环和浏览器的事件循环的区别</span></a></h2><ol><li>浏览器的事件循环是宏任务和微任务交替执行，node 的事件循环是宏任务和微任务交替执行，但是宏任务之间不是交替执行，而是顺序执行</li><li>node 的事件循环是 6 个阶段，浏览器的事件循环是 2 个阶段</li></ol>',32)],c={},g=(0,s(6262).A)(c,[["render",function(e,a){return(0,n.uX)(),(0,n.CE)("div",null,h)}]]),m=JSON.parse('{"path":"/accumulation/eventLoop.html","title":"浏览器事件循环","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"进程和线程","slug":"进程和线程","link":"#进程和线程","children":[]},{"level":2,"title":"浏览器的事件循环","slug":"浏览器的事件循环","link":"#浏览器的事件循环","children":[]},{"level":2,"title":"微任务和宏任务","slug":"微任务和宏任务","link":"#微任务和宏任务","children":[]},{"level":2,"title":"node 的事件循环分为 6 个阶段","slug":"node-的事件循环分为-6-个阶段","link":"#node-的事件循环分为-6-个阶段","children":[]},{"level":2,"title":"node 的宏任务和微任务","slug":"node-的宏任务和微任务","link":"#node-的宏任务和微任务","children":[]},{"level":2,"title":"node 的事件循环和浏览器的事件循环的区别","slug":"node-的事件循环和浏览器的事件循环的区别","link":"#node-的事件循环和浏览器的事件循环的区别","children":[]}],"git":{},"filePathRelative":"accumulation/eventLoop.md"}')}}]);