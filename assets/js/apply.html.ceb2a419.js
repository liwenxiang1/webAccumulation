"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[6262],{3608:(l,a,n)=>{n.r(a),n.d(a,{comp:()=>d,data:()=>t});var i=n(641);const p=[(0,i.Fv)('<h1 id="js-基础系列-重新认识-call-apply-bind" tabindex="-1"><a class="header-anchor" href="#js-基础系列-重新认识-call-apply-bind"><span>JS 基础系列-重新认识 call apply bind</span></a></h1><h2 id="call-apply-bind-基本介绍" tabindex="-1"><a class="header-anchor" href="#call-apply-bind-基本介绍"><span>call apply bind 基本介绍</span></a></h2><p><strong>语法</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>fun.call(thisArg,params1,params2,...)\nfun.apply(thisArg,[params1,params2,...])\nfun.bind(thisArg,params1,params2,...)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>返回值</strong></p><ol><li>call/apply:返回的是执行的结果</li><li>bind:返回的是<code>fun</code>的拷贝，并拥有指定的<code>this</code>以及初始参数</li></ol><p><strong>参数</strong><code>thisArg</code>（可选）：</p><ol><li>fun 的 this 指向 thisArg</li><li>非严格模式下：thisArg 指定为 null,undefined,fun 中的 this 指向的是 window 对象</li><li>严格模式下：fun 的 this 为 undefined</li><li>值为原始值（字符串，数字，布尔值）的 this 指向的是原始对象，如 String,Number,Boolean</li></ol><p><code>params1，...</code>（可选）</p><ol><li>如果 params 不传或者未 numm,undefined。则表示不需要传入参数</li><li>apply 第二个参数是数组，数组中的值为传给 fun 的参数</li></ol><p><strong>调用 call/apply/bind 必须是函数</strong></p><blockquote><p>call,apply,bind 是挂在 Function 对象的三个方法，只有函数才有 例如：Object.prototype.toString.call(data)</p></blockquote><p><strong>区别</strong></p><p><strong><em>call 与 apply 的区别</em></strong></p><p>传参写法不同：</p><ul><li><code>apply</code> 第二个参数是传给 fun 的，他是个数组</li><li><code>call</code> 从第 2 个开始都是传给 fun 的参数</li></ul><p><strong><em>call /apply 与 bind 的区别</em></strong></p><p><strong>执行：</strong></p><ul><li><code>call/apply</code> 改变函数的 this 指向后立马<strong>执行该函数</strong></li><li><code>bind</code> 返回改变了上下文之后的函数，<strong>不执行改函数</strong></li></ul><p><strong>返回值</strong></p><ul><li>call/apply 返回的是执行的结果</li><li>bind 返回的是 fun 的拷贝，并指定了 fun 的 this 的指向，保存了 fun 的参数</li></ul><h2 id="call-apply-bind-的核心理念-借用方法" tabindex="-1"><a class="header-anchor" href="#call-apply-bind-的核心理念-借用方法"><span>call/apply/bind 的核心理念：借用方法</span></a></h2><p>Ad 对象有个方法，B 对象出于某种原因也需要该方法，那么我们就向 A 对象借用一下，几达到目的又节省了内存</p>',23)],e={},d=(0,n(6262).A)(e,[["render",function(l,a){return(0,i.uX)(),(0,i.CE)("div",null,p)}]]),t=JSON.parse('{"path":"/accumulation/apply.html","title":"JS 基础系列-重新认识 call apply bind","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"call apply bind 基本介绍","slug":"call-apply-bind-基本介绍","link":"#call-apply-bind-基本介绍","children":[]},{"level":2,"title":"call/apply/bind 的核心理念：借用方法","slug":"call-apply-bind-的核心理念-借用方法","link":"#call-apply-bind-的核心理念-借用方法","children":[]}],"git":{},"filePathRelative":"accumulation/apply.md"}')}}]);