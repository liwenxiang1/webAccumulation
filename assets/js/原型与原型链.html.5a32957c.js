"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[128],{3223:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>p,data:()=>c});var t=a(641);const e=[(0,t.Fv)('<h2 id="原型与原型链" tabindex="-1"><a class="header-anchor" href="#原型与原型链"><span>原型与原型链</span></a></h2><p>在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 <code>prototype</code> 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个<code>指针</code>，这个指针指向构造函数的 <code>prototype</code> 属性对应的值，在 ES5 中这个<code>指针</code>被称为<code>对象的原型</code>。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <code>__proto__</code> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 <code>Object.getPrototypeOf()</code> 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <code>Object.prototype</code> 所以这就是新建的对象为什么能够使用 <code>toString() </code>等方法的原因。</p><blockquote><p>特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一 改变。</p></blockquote><p><strong>如何获得对象非原型链上的属性？</strong> 使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">iterate</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">&#39;: &#39;</span> <span class="token operator">+</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>执行上下文中 <code>this</code> 的指向：</strong></p><ol><li>在全局执行上下文中，<code>this</code> 指向全局对象（window 对象）</li><li>在函数执行上下文中，<code>this</code> 指向取决于函数如何调用。如果它被一个引用对象调用，那么 <strong><code>this</code> 会被设置成那个对象</strong>，否则<strong>this 的值被设置为全局对象或者 undefined</strong></li></ol>',8)],o={},p=(0,a(6262).A)(o,[["render",function(n,s){return(0,t.uX)(),(0,t.CE)("div",null,e)}]]),c=JSON.parse('{"path":"/mianshi/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"原型与原型链","slug":"原型与原型链","link":"#原型与原型链","children":[]}],"git":{},"filePathRelative":"mianshi/原型与原型链.md"}')}}]);