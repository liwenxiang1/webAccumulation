"use strict";(self.webpackChunkliwx_docs=self.webpackChunkliwx_docs||[]).push([[3797],{6673:(e,n,i)=>{i.r(n),i.d(n,{comp:()=>f,data:()=>L});var l=i(641);const a=(0,l.Lk)("h1",{id:"js基础",tabindex:"-1"},[(0,l.Lk)("a",{class:"header-anchor",href:"#js基础"},[(0,l.Lk)("span",null,"js基础")])],-1),s={id:"一、class的使用参考",tabindex:"-1"},d={class:"header-anchor",href:"#一、class的使用参考"},t=(0,l.Lk)("a",{href:"code/js-code/class.js"},"class",-1),c={href:"http://jsrun.net/t/SZKKp",target:"_blank",rel:"noopener noreferrer"},r=(0,l.Fv)('<blockquote><p>this的指向 <code>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</code></p></blockquote><p><strong>下面的代码就会导致class类里面的this不能正确引用</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>class Logger {\n    printName(name = &#39;there&#39;) {\n        this.print(`Hello ${name}`);\n    }\n\n    print(text) {\n        console.log(text);\n    }\n}\n\nconst logger = new Logger();\nconst {printName} = logger;\nprintName(); // TypeError: Cannot read property &#39;print&#39; of undefined\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解决方法一：<code>在构造方法中绑定this，这样就不会找不到print方法了。</code></li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>class Logger {\n  constructor() {\n    this.printName = this.printName.bind(this);\n  }\n\n  // ...\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解决方法二：<code>使用箭头函数</code></li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>class Logger {\n  constructor() {\n    this.printName = (name = &#39;there&#39;) =&gt; {\n      this.print(`Hello ${name}`);\n    };\n  }\n\n  // ...\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二、function的使用" tabindex="-1"><a class="header-anchor" href="#二、function的使用"><span>二、<a href="code/js-code/function.js">function</a>的使用</span></a></h3>',8),v={id:"三、async函数使用参考",tabindex:"-1"},u={class:"header-anchor",href:"#三、async函数使用参考"},o={href:"http://jsrun.net/t/MZKKp",target:"_blank",rel:"noopener noreferrer"},m=(0,l.Fv)('<ul><li>1.await 容易引入错误，需要try-catch包裹<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>async function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  };\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>2.多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//继发关系\nlet foo = await getFoo();\nlet bar = await getBar();\n// 同时触发\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>3.<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//for循环继发操作\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n//对数组的数据进行多个请求并发执行\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) =&gt; db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>',1),b={id:"四、module使用参考",tabindex:"-1"},h={class:"header-anchor",href:"#四、module使用参考"},g={href:"http://jsrun.net/t/KgKKp",target:"_blank",rel:"noopener noreferrer"},p={id:"五、callback接口回调使用callback",tabindex:"-1"},k={class:"header-anchor",href:"#五、callback接口回调使用callback"},x={},f=(0,i(6262).A)(x,[["render",function(e,n){const i=(0,l.g2)("ExternalLinkIcon"),x=(0,l.g2)("RouteLink");return(0,l.uX)(),(0,l.CE)("div",null,[a,(0,l.Lk)("h3",s,[(0,l.Lk)("a",d,[(0,l.Lk)("span",null,[(0,l.eW)("一、"),t,(0,l.eW)("的使用"),(0,l.Lk)("a",c,[(0,l.eW)("参考"),(0,l.bF)(i)])])])]),r,(0,l.Lk)("h3",v,[(0,l.Lk)("a",u,[(0,l.Lk)("span",null,[(0,l.eW)("三、async函数使用"),(0,l.Lk)("a",o,[(0,l.eW)("参考"),(0,l.bF)(i)])])])]),m,(0,l.Lk)("h3",b,[(0,l.Lk)("a",h,[(0,l.Lk)("span",null,[(0,l.eW)("四、module使用"),(0,l.Lk)("a",g,[(0,l.eW)("参考"),(0,l.bF)(i)])])])]),(0,l.Lk)("h3",p,[(0,l.Lk)("a",k,[(0,l.Lk)("span",null,[(0,l.eW)("五、callback接口回调使用"),(0,l.bF)(x,{to:"/markdown/%E5%89%8D%E7%AB%AF/html/code/js-code/callback.html"},{default:(0,l.k6)((()=>[(0,l.eW)("callback")])),_:1})])])])])}]]),L=JSON.parse('{"path":"/markdown/%E5%89%8D%E7%AB%AF/html/js%E5%9F%BA%E7%A1%80.html","title":"js基础","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"一、class的使用参考","slug":"一、class的使用参考","link":"#一、class的使用参考","children":[]},{"level":3,"title":"二、function的使用","slug":"二、function的使用","link":"#二、function的使用","children":[]},{"level":3,"title":"三、async函数使用参考","slug":"三、async函数使用参考","link":"#三、async函数使用参考","children":[]},{"level":3,"title":"四、module使用参考","slug":"四、module使用参考","link":"#四、module使用参考","children":[]},{"level":3,"title":"五、callback接口回调使用callback","slug":"五、callback接口回调使用callback","link":"#五、callback接口回调使用callback","children":[]}],"git":{},"filePathRelative":"markdown/前端/html/js基础.md"}')}}]);